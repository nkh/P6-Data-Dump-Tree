
folding
	#pass an object and apply folding role on top

	large renderings are slow to scroll
		probably NCurses related as get_lines is 0.004s and 0.0006s when cached

object size

NCurses
	#support multi line entries

	#utility sub
	render unicode
	
dhtml
	user css override
	visual cue for folds

render role inheritance
	eg: role X does Y

#ddt adverbs
	:curses

	db_send for ddt
		ddt :remote / :remote(8888)
		ddt :remote_fold, send lines and fold data, no need for objects!

	ddt :get instead for get_dump

#Role dumping
   │ .DDTR::AsciiGlyphs .DDT exception :  No such method 'parents' for invocant of type 'Perl6::Metamodel::ParametricRoleGr
   │ oupHOW':U <Uninstantiable>

#NativeCall

#re-integrate Test::META

#add Horizontal in META6.json

#Sub, Block, Method, ..
	better rendering

#role added to DDT handled classes
	ie: MaxLine is a role added to an array but is not visible when the array is dumped

#flat
	#when element if seen in sub element rendering for the first time, it gets
		index 0 rather than the next index

	#in column mode, if a sub element rendering passes the column max row
		move next element to next column

		eg: if a column contains 5 elements with each a sub element that takes
		10 lines to render, then the column will be 50 in hight, instead, if a
		element passes the column row limit, the next element is shifted to next column
		
		in the eg above this could become 5 column of ten(ish) lines rather than one
		column of 50+lines. 

	#simplified Block interface

	#pass options to sub dumper
	#flatten all

	#ddt $s, :flat, ... # flatten level 0
	#ddt $s, :flat(4,5) # flatten level 4 and 5, where 5 is in a sub dumper and it is its level 0
	#ddt $s, :flat(Array, sub($s, $d){}, ...), # arguments to flat
	#ddt $s, :flat($s{name}[12]), # flatten specfic element
	#ddt $s, :flat<3>, :flat_title<some banner>

#multiple arguments
	#handle options override
	!option to have them bunched together rather than separate 

#extra attributes
	#display origin
	#display readonly, default, required deprecate

#display sequences by default ?
#display full sequences or just part ?

#multi columns
	#support width and wrapping of columns
	#share seen references between columns and main dumper
	return heigh and columns' widths
	#what when width is much larger, seems that some text is lost

#Tuples
	#dumping data vertically has the disadvantages of forcing one to scroll down
	EG: a list of 10 elements each with three elements is 40 lines long
	often we want to see the three elements by each other which means 20 lines
	we can also inline the 3 elements with their container which makes the dump ten lines

	#in extreme cases, rendering the data as a table is the best solution

	#this can be done with filter but means a lot of boilerplate code

	create a tuple/table plugin filter with simplified interface 
		also tag an array or list to get it's elements displayed horizontally 
			if the list elements are too wide, display them on multiple lines

	#tuples could also be parts of the dump, with color	

#override default colors without having to redefine all of them

Create a handler DDTR
# .Data::Dump::Tree+{DDTR::AnsiGlyphs} .Data::Dump::Tree @0
#
# remove &ansicolor, do not show the colors
# ├ $.colorizer = .AnsiColor @1
# │ │ removing %!color_lookup
# │ ├ $.is_ansi = True.Bool
# │ └ &.ansicolor = color.Sub
#
# ├ $.title = Nil.Str
# ├ $.caller = False.Bool
# 
# ├ $.color = False.Bool
# 
# │ removing %.colors
# show the colors in color
#
# ├ $.color_glyphs = Nil.Str
# ├ @.glyph_colors = [1] @4
# │ └ 0 = glyph_1.Str
# ├ @.glyph_colors_cycle = [0] @5
#
# ├ $.color_kbs = Nil.Str
# display over all the color information 
#
# ├ @.kb_colors = [1] @6
# │ └ 0 = kb_1.Str
# ├ @.kb_colors_cycle = [0] @7
#
# ├ @.header_filters = [0] @8
# ├ @.elements_filters = [0] @9
# ├ @.footer_filters = [0] @10
# horizontal check list
#
#
# ├ $!address = Nil.Str
# ├ %!rendered = {0} @11
# 
# ├ %!element_names = {0} @12
#
#
# ├ $.display_address = DDT_DISPLAY_CONTAINER.DDT_Address_Display
# ├ $.display_info = True.Bool
# ├ $.display_type = True.Bool
# ├ $.display_perl_address = False.Bool

# ├ $.keep_paths = False.Bool
# ├ %.paths = {0} @13
# remove
#
# ├ $.width = Nil.Str
# ├ $.max_depth = -1.Int
# ├ $.max_depth_message = True.Bool

# └ @!renderings = [0] @14
# remove

#ColorStr class
	keeps color and string separated, or colored string and length of uncolored string

eqv not implemented for Match

#2 colums display of dumps
	given two dumps, handle colors, etc ... and show both side by side


#why can't pass role (does =>) with argument

#Allow filter to add text to the rendering of an element

#display a[0..1| as a[0]

#Only container containers can have names
	give names to all possible elements or example a filter that can add names/hilight

#user defined address name
	is some nodes are of specific importance, give them name that can be used to 
	display the reference rather than a standard @1234, eg, @important_node

#color objects

#scoped filters

#paths
	can be used in filters
	
#diff list
	can use paths

#test::compare:DDT::diff

#roles to sub dump

#filters on generic containers
!scoped filter and roles
	=> path and depth are enough for now

Requirements:

user interaction layer
	!cache
		to avoid re-generating the data
	
	representation in
		Prima, curses, gtk, dhtml, #terminal


dumper
	#options
		#max depth, ...

	name
		allow dumper to be switched on and off by name at higher level
		eg: a piece of code contains a dumper but the user wants to control
			in which scope the dump should be done		

	#handles multiple iterators
		synchronized glyphs (diff)

	#returns one or multiple "row representations"
		multiple rows have synchronization points

	#start and end tag per level
		ease generation of HTML for example

	#user defined filters

	#dumps can be gathered from multiple source dynamically
		when getting to a specific point, data is gathered from another source
		no need to create a data structure in advance
	
		=> any object can declare handler, including dynamic sources

	!dump, gather, dump_gathered, reset interface.

	!dumper can re-synchronize the glyphs
		if a stream ends, the glyph for the previous element
		may need to be changed	

	supports threads

	!lazy row representation element generation

	!can modify a previous glyph if the level after it is not the expected one
		ie, an element becomes the latest in the level

	#when dumping multiple structures simultaneously
		diff color
		diff column
		diff glyphs

#row representation
	can contain multiple fields for each data element dumped
		level, #data, #type, #inheritance, size, taint, tie, weak references, ...
	
	#user registrable representation generators
	class defined generator
		it can use this module and the glyphs get aligned properly

	#colorizer
		per level
		per type

	!lazy representation generation

	},

#data iterator
	from data structure
	from feeder
		ie data can come from a stream


#glyph generator
	option for different glyph representations

	generate a glyph based on a hierarchical level
		method, input level, input glyphs, output a string


